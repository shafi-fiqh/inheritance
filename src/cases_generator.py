"""
This module is to be used to generate inheritance cases.
Configuration files specify the base set of inheritors to permute.
Number of different types of inheritors passed as a parameter.
Saving the cases to a csv is an option.
"""
import argparse
import itertools
import logging
import os
import pandas as pd

from utils.helpers import is_redundant


class CaseGenerator:
    """
    The parent case generation class. Can generate inheritance cases from a config
    and save them.
    """
    def __init__(self,
                 config: str) -> None:
        """
        Initialize the list of inheritors.
        This can increase to more sophisticated levels in the future.
        :param config: Comma separated file containing the inheritors.
        """
        family_csv = pd.read_csv(config)
        self.inheritors = list(family_csv['Inheritor'])
        self.descendants = pd.Series(family_csv.descendant.values, index=family_csv.Inheritor).to_dict()
        logging.info(self.descendants)
        self.n_types=None
        self.generator=None
    def generate_cases(self,
                       n_types: int) -> itertools.combinations:
        """
        Generator object for inheritance cases to be solved.
        :param n_types: number of distinct different types of inheritors.
        For example Daughter + Son is considered 2 types.
        Daugher x 2 + Son is still considered n_types = 2.
        :return: Generator object for inheritane cases with the specified types
        """
        self.n_types = n_types
        self.generator = itertools.combinations(self.inheritors, n_types)
        return self.generator
    def save_cases(self,
                   output: str,
                   chunk_size: int) -> None:
        """
        Append cases to an output file.
        We will yield and append cases one by one to the file to avoid memory issues,
        as the permutation space can get quite large.
        :param output: string for the csv filepath
        :return: None
        """
        columns = ['Case']
        base = pd.DataFrame(columns=columns)
        base.to_csv(output, index=False)
        n_cases=0
        for case in self.generator:
            #Later to be filled by the solver
            case = {x: 0 for x in case}
            if not is_redundant(case):
                temp = pd.DataFrame({'Case': [case]})
                base=base.append(temp)
                n_cases+=1
                if n_cases % chunk_size == 0:
                    base.to_csv(output, mode='a', index=False, header=False)
                    base = pd.DataFrame(columns=columns)
        #Add the remainder to the csv, unless it stopped exactly on a chunk_size multiple.
        if n_cases % chunk_size != 0:
            base.to_csv(output, mode='a', index=False, header=False)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Case generator parameters')
    parser.add_argument("--config",
                        type=str,
                        required='True',
                        help="Path to the csv file containing the list of inheritors")
    parser.add_argument("--n_types",
                        type=int,
                        required='True',
                        help="Size of the inheritance cases generated by type of inheritor.")
    parser.add_argument("--output",
                        type=str,
                        required='True',
                        help="Output filename for the generated cases")
    args = parser.parse_args()
    casegen = CaseGenerator(args.config)
    casegen.generate_cases(args.n_types)
    casegen.save_cases(os.path.join('output', args.output), chunk_size=10000)
